

import json
import os
from pathlib import Path
import re
import requests
import sys
# suppress InsecureRequestWarning generated by request from verify=False
from requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

TUMBLR_BLOGNAME_REGEX = 'https?:\/\/(\S*)\.tumblr\.com'
TUMBLR_POST_ID_REGEX = '\/post\/(\d*)'

DOWNLOAD_RAW = False
# tumblr's embedded api key
API_KEY = "fuiKNFp9vQFvjLNvx4sUwti4Yb5yGutBN4Xh10LXZhhRKjWlV4"
TUMBLR_API = "https://api.tumblr.com/v2/blog/"
GET_POST = ".tumblr.com/posts?api_key=" + API_KEY + "&id="

# returns True if
# 1. file downloaded successfully
# returns False if
# 1. file download fails
# 2. file already exists
def download_file(download_url, save_path):
    # determine file name
    file_name = download_url.split('/')[-1]
    file_name = file_name.split('\\')[-1]

    file_location = Path(save_path, file_name)
    download_status = False

    if not file_location.is_file():
        # set verify=False to bypass aws ssl error
        response = requests.get(download_url, verify=False)
        if response.status_code == 200:
            with open(file_location, 'wb') as f:
                f.write(response.content)
                download_status = True
    else:
        print(file_name + " already exists")

    return download_status


def get_raw_photo_url(photo_url):
    # get extension
    ext = '.' + photo_url.rsplit('.', 1)[1]

    # change to raw
    raw_photo_url = photo_url.rsplit('_', 1)[0] # get portion before _
    raw_photo_url = raw_photo_url + '_' + 'raw' + ext

    # change numbers.media to data
    raw_photo_url = re.sub('\d+.media', 'data', raw_photo_url)

    return raw_photo_url


def download_photos(blogpost_content, dir_name):
    photo_urls = blogpost_content['photos']
    for url in photo_urls:
        photo_url = url['original_size']['url']
        if DOWNLOAD_RAW:
            photo_url = get_raw_photo_url(photo_url)
        download_file(photo_url, dir_name)


def download_video(blogpost_content, dir_name):
    video_url = blogpost_content['video_url']
    download_file(video_url, dir_name)


def get_blogpost_content(post_api_url):
    print("Initiating download")

    with requests.session() as client:
        res = client.get(post_api_url)
        if res.status_code != 200:
            raise "Invalid request"

        response_json = json.loads(res.content)
        blogpost_content = response_json['response']['posts'][0]
        dir_name = blogpost_content['blog_name'] + '_' + str(blogpost_content['id'])
        # create directory if it does not exist
        if not os.path.exists(dir_name):
            os.makedirs(dir_name)

        # get type
        blogpost_type = blogpost_content['type']
        if blogpost_type == 'photo':
            download_photos(blogpost_content, dir_name)
        elif blogpost_type == 'video':
            download_video(blogpost_content, dir_name)

    print("Download(s) complete")


def get_tumblr_name(post_url):
    match = re.search(TUMBLR_BLOGNAME_REGEX, post_url)
    return match.group(1)


def get_tumblr_post_id(post_url):
    match = re.search(TUMBLR_POST_ID_REGEX, post_url)
    return match.group(1)


def main():
    if len(sys.argv) != 2:
        print("Incorrect arguments")
        print("Run in the following format")
        print("python dl_tumblr_post.py {tumblr_post_url}")
        exit()
    post_url = sys.argv[1]
    blog_url = get_tumblr_name(post_url)
    post_id = get_tumblr_post_id(post_url)

    post_api_url = TUMBLR_API + blog_url + GET_POST + str(post_id)
    get_blogpost_content(post_api_url)


if __name__ == "__main__":
    main()
